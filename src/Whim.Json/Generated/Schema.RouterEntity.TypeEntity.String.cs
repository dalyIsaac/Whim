//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
using System.Buffers;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Text;
using System.Text.Json;
using Corvus.Json;
using Corvus.Json.Internal;

namespace Whim.Json;
public readonly partial struct Schema
{
    public readonly partial struct RouterEntity
    {
        /// <summary>
        /// Generated from JSON Schema.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The type of router to apply. For more, see https://dalyisaac.github.io/Whim/docs/customize/routing.html
        /// </para>
        /// </remarks>
        public readonly partial struct TypeEntity 
#if NET8_0_OR_GREATER
    : IJsonString<TypeEntity>, ISpanFormattable
#else
        : IJsonString<TypeEntity>
#endif
        {
            /// <summary>
            /// Initializes a new instance of the <see cref = "TypeEntity"/> struct.
            /// </summary>
            /// <param name = "value">The value from which to construct the instance.</param>
            public TypeEntity(string value)
            {
                this.jsonElementBacking = default;
                this.backing = Backing.String;
                this.stringBacking = value;
            }

            /// <summary>
            /// Conversion from string.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator TypeEntity(string value)
            {
                return new(value);
            }

            /// <summary>
            /// Conversion from JsonString.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            public static implicit operator TypeEntity(JsonString value)
            {
                if (value.HasDotnetBacking && value.ValueKind == JsonValueKind.String)
                {
                    return new(value.GetString()!);
                }

                return new(value.AsJsonElement);
            }

            /// <summary>
            /// Conversion to string.
            /// </summary>
            /// <param name = "value">The value from which to convert.</param>
            /// <exception cref = "InvalidOperationException">The value was not a string.</exception>
            public static explicit operator string (TypeEntity value)
            {
                if ((value.backing & Backing.JsonElement) != 0)
                {
                    if (value.jsonElementBacking.GetString()is string result)
                    {
                        return result;
                    }

                    throw new InvalidOperationException();
                }

                if ((value.backing & Backing.String) != 0)
                {
                    return value.stringBacking;
                }

                throw new InvalidOperationException();
            }

            /// <summary>
            /// Concatenate two JSON values, producing an instance of the string type TypeEntity.
            /// </summary>
            /// <typeparam name = "T1">The type of the first value.</typeparam>
            /// <typeparam name = "T2">The type of the second value.</typeparam>
            /// <param name = "buffer">The buffer into which to concatenate the values.</param>
            /// <param name = "firstValue">The first value.</param>
            /// <param name = "secondValue">The second value.</param>
            /// <returns>An instance of this string type.</returns>
            public static TypeEntity Concatenate<T1, T2>(Span<byte> buffer, in T1 firstValue, in T2 secondValue)
                where T1 : struct, IJsonValue<T1> where T2 : struct, IJsonValue<T2>
            {
                int written = LowAllocJsonUtils.ConcatenateAsUtf8JsonString(buffer, firstValue, secondValue);
                return ParseValue(buffer[..written]);
            }

            /// <summary>
            /// Concatenate three JSON values, producing an instance of the string type TypeEntity.
            /// </summary>
            /// <typeparam name = "T1">The type of the first value.</typeparam>
            /// <typeparam name = "T2">The type of the second value.</typeparam>
            /// <typeparam name = "T3">The type of the third value.</typeparam>
            /// <param name = "buffer">The buffer into which to concatenate the values.</param>
            /// <param name = "firstValue">The first value.</param>
            /// <param name = "secondValue">The second value.</param>
            /// <param name = "thirdValue">The third value.</param>
            /// <returns>An instance of this string type.</returns>
            public static TypeEntity Concatenate<T1, T2, T3>(Span<byte> buffer, in T1 firstValue, in T2 secondValue, in T3 thirdValue)
                where T1 : struct, IJsonValue<T1> where T2 : struct, IJsonValue<T2> where T3 : struct, IJsonValue<T3>
            {
                int written = LowAllocJsonUtils.ConcatenateAsUtf8JsonString(buffer, firstValue, secondValue, thirdValue);
                return ParseValue(buffer[..written]);
            }

            /// <summary>
            /// Concatenate four JSON values, producing an instance of the string type TypeEntity.
            /// </summary>
            /// <typeparam name = "T1">The type of the first value.</typeparam>
            /// <typeparam name = "T2">The type of the second value.</typeparam>
            /// <typeparam name = "T3">The type of the third value.</typeparam>
            /// <typeparam name = "T4">The type of the fourth value.</typeparam>
            /// <param name = "buffer">The buffer into which to concatenate the values.</param>
            /// <param name = "firstValue">The first value.</param>
            /// <param name = "secondValue">The second value.</param>
            /// <param name = "thirdValue">The third value.</param>
            /// <param name = "fourthValue">The fourth value.</param>
            /// <returns>An instance of this string type.</returns>
            public static TypeEntity Concatenate<T1, T2, T3, T4>(Span<byte> buffer, in T1 firstValue, in T2 secondValue, in T3 thirdValue, in T4 fourthValue)
                where T1 : struct, IJsonValue<T1> where T2 : struct, IJsonValue<T2> where T3 : struct, IJsonValue<T3> where T4 : struct, IJsonValue<T4>
            {
                int written = LowAllocJsonUtils.ConcatenateAsUtf8JsonString(buffer, firstValue, secondValue, thirdValue, fourthValue);
                return ParseValue(buffer[..written]);
            }

            /// <summary>
            /// Concatenate five JSON values, producing an instance of the string type TypeEntity.
            /// </summary>
            /// <typeparam name = "T1">The type of the first value.</typeparam>
            /// <typeparam name = "T2">The type of the second value.</typeparam>
            /// <typeparam name = "T3">The type of the third value.</typeparam>
            /// <typeparam name = "T4">The type of the fourth value.</typeparam>
            /// <typeparam name = "T5">The type of the fifth value.</typeparam>
            /// <param name = "buffer">The buffer into which to concatenate the values.</param>
            /// <param name = "firstValue">The first value.</param>
            /// <param name = "secondValue">The second value.</param>
            /// <param name = "thirdValue">The third value.</param>
            /// <param name = "fourthValue">The fourth value.</param>
            /// <param name = "fifthValue">The fifth value.</param>
            /// <returns>An instance of this string type.</returns>
            public static TypeEntity Concatenate<T1, T2, T3, T4, T5>(Span<byte> buffer, in T1 firstValue, in T2 secondValue, in T3 thirdValue, in T4 fourthValue, in T5 fifthValue)
                where T1 : struct, IJsonValue<T1> where T2 : struct, IJsonValue<T2> where T3 : struct, IJsonValue<T3> where T4 : struct, IJsonValue<T4> where T5 : struct, IJsonValue<T5>
            {
                int written = LowAllocJsonUtils.ConcatenateAsUtf8JsonString(buffer, firstValue, secondValue, thirdValue, fourthValue, fifthValue);
                return ParseValue(buffer[..written]);
            }

            /// <summary>
            /// Concatenate six JSON values, producing an instance of the string type TypeEntity.
            /// </summary>
            /// <typeparam name = "T1">The type of the first value.</typeparam>
            /// <typeparam name = "T2">The type of the second value.</typeparam>
            /// <typeparam name = "T3">The type of the third value.</typeparam>
            /// <typeparam name = "T4">The type of the fourth value.</typeparam>
            /// <typeparam name = "T5">The type of the fifth value.</typeparam>
            /// <typeparam name = "T6">The type of the sixth value.</typeparam>
            /// <param name = "buffer">The buffer into which to concatenate the values.</param>
            /// <param name = "firstValue">The first value.</param>
            /// <param name = "secondValue">The second value.</param>
            /// <param name = "thirdValue">The third value.</param>
            /// <param name = "fourthValue">The fourth value.</param>
            /// <param name = "fifthValue">The fifth value.</param>
            /// <param name = "sixthValue">The sixth value.</param>
            /// <returns>An instance of this string type.</returns>
            public static TypeEntity Concatenate<T1, T2, T3, T4, T5, T6>(Span<byte> buffer, in T1 firstValue, in T2 secondValue, in T3 thirdValue, in T4 fourthValue, in T5 fifthValue, in T6 sixthValue)
                where T1 : struct, IJsonValue<T1> where T2 : struct, IJsonValue<T2> where T3 : struct, IJsonValue<T3> where T4 : struct, IJsonValue<T4> where T5 : struct, IJsonValue<T5> where T6 : struct, IJsonValue<T6>
            {
                int written = LowAllocJsonUtils.ConcatenateAsUtf8JsonString(buffer, firstValue, secondValue, thirdValue, fourthValue, fifthValue, sixthValue);
                return ParseValue(buffer[..written]);
            }

            /// <summary>
            /// Concatenate seven JSON values, producing an instance of the string type TypeEntity.
            /// </summary>
            /// <typeparam name = "T1">The type of the first value.</typeparam>
            /// <typeparam name = "T2">The type of the second value.</typeparam>
            /// <typeparam name = "T3">The type of the third value.</typeparam>
            /// <typeparam name = "T4">The type of the fourth value.</typeparam>
            /// <typeparam name = "T5">The type of the fifth value.</typeparam>
            /// <typeparam name = "T6">The type of the sixth value.</typeparam>
            /// <typeparam name = "T7">The type of the seventh value.</typeparam>
            /// <param name = "buffer">The buffer into which to concatenate the values.</param>
            /// <param name = "firstValue">The first value.</param>
            /// <param name = "secondValue">The second value.</param>
            /// <param name = "thirdValue">The third value.</param>
            /// <param name = "fourthValue">The fourth value.</param>
            /// <param name = "fifthValue">The fifth value.</param>
            /// <param name = "sixthValue">The sixth value.</param>
            /// <param name = "seventhValue">The seventh value.</param>
            /// <returns>An instance of this string type.</returns>
            public static TypeEntity Concatenate<T1, T2, T3, T4, T5, T6, T7>(Span<byte> buffer, in T1 firstValue, in T2 secondValue, in T3 thirdValue, in T4 fourthValue, in T5 fifthValue, in T6 sixthValue, in T7 seventhValue)
                where T1 : struct, IJsonValue<T1> where T2 : struct, IJsonValue<T2> where T3 : struct, IJsonValue<T3> where T4 : struct, IJsonValue<T4> where T5 : struct, IJsonValue<T5> where T6 : struct, IJsonValue<T6> where T7 : struct, IJsonValue<T7>
            {
                int written = LowAllocJsonUtils.ConcatenateAsUtf8JsonString(buffer, firstValue, secondValue, thirdValue, fourthValue, fifthValue, sixthValue, seventhValue);
                return ParseValue(buffer[..written]);
            }

            /// <summary>
            /// Concatenate eight JSON values, producing an instance of the string type TypeEntity.
            /// </summary>
            /// <typeparam name = "T1">The type of the first value.</typeparam>
            /// <typeparam name = "T2">The type of the second value.</typeparam>
            /// <typeparam name = "T3">The type of the third value.</typeparam>
            /// <typeparam name = "T4">The type of the fourth value.</typeparam>
            /// <typeparam name = "T5">The type of the fifth value.</typeparam>
            /// <typeparam name = "T6">The type of the sixth value.</typeparam>
            /// <typeparam name = "T7">The type of the seventh value.</typeparam>
            /// <typeparam name = "T8">The type of the eighth value.</typeparam>
            /// <param name = "buffer">The buffer into which to concatenate the values.</param>
            /// <param name = "firstValue">The first value.</param>
            /// <param name = "secondValue">The second value.</param>
            /// <param name = "thirdValue">The third value.</param>
            /// <param name = "fourthValue">The fourth value.</param>
            /// <param name = "fifthValue">The fifth value.</param>
            /// <param name = "sixthValue">The sixth value.</param>
            /// <param name = "seventhValue">The seventh value.</param>
            /// <param name = "eighthValue">The eighth value.</param>
            /// <returns>An instance of this string type.</returns>
            public static TypeEntity Concatenate<T1, T2, T3, T4, T5, T6, T7, T8>(Span<byte> buffer, in T1 firstValue, in T2 secondValue, in T3 thirdValue, in T4 fourthValue, in T5 fifthValue, in T6 sixthValue, in T7 seventhValue, in T8 eighthValue)
                where T1 : struct, IJsonValue<T1> where T2 : struct, IJsonValue<T2> where T3 : struct, IJsonValue<T3> where T4 : struct, IJsonValue<T4> where T5 : struct, IJsonValue<T5> where T6 : struct, IJsonValue<T6> where T7 : struct, IJsonValue<T7> where T8 : struct, IJsonValue<T8>
            {
                int written = LowAllocJsonUtils.ConcatenateAsUtf8JsonString(buffer, firstValue, secondValue, thirdValue, fourthValue, fifthValue, sixthValue, seventhValue, eighthValue);
                return ParseValue(buffer[..written]);
            }

            /// <inheritdoc/>
            public bool TryGetString([NotNullWhen(true)] out string? value)
            {
                if ((this.backing & Backing.String) != 0)
                {
                    value = this.stringBacking;
                    return true;
                }

                if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.String)
                {
                    value = this.jsonElementBacking.GetString();
                    return value is not null;
                }

                value = null;
                return false;
            }

            /// <summary>
            /// Gets the string value.
            /// </summary>
            /// <returns><c>The string if this value represents a string</c>, otherwise <c>null</c>.</returns>
            public string? GetString()
            {
                if (this.TryGetString(out string? value))
                {
                    return value;
                }

                return null;
            }

            /// <summary>
            /// Compare to a sequence of characters.
            /// </summary>
            /// <param name = "utf8Bytes">The UTF8-encoded character sequence to compare.</param>
            /// <returns><c>True</c> if teh sequences match.</returns>
            public bool EqualsUtf8Bytes(ReadOnlySpan<byte> utf8Bytes)
            {
                if ((this.backing & Backing.JsonElement) != 0)
                {
                    if (this.jsonElementBacking.ValueKind == JsonValueKind.String)
                    {
                        return this.jsonElementBacking.ValueEquals(utf8Bytes);
                    }
                }

                if ((this.backing & Backing.String) != 0)
                {
                    int maxCharCount = Encoding.UTF8.GetMaxCharCount(utf8Bytes.Length);
#if NET8_0_OR_GREATER
            char[]? pooledChars = null;

            Span<char> chars = maxCharCount <= JsonValueHelpers.MaxStackAlloc  ?
                stackalloc char[maxCharCount] :
                (pooledChars = ArrayPool<char>.Shared.Rent(maxCharCount));

            try
            {
                int written = Encoding.UTF8.GetChars(utf8Bytes, chars);
                return chars[..written].SequenceEqual(this.stringBacking);
            }
            finally
            {
                if (pooledChars is char[] pc)
                {
                    ArrayPool<char>.Shared.Return(pc);
                }
            }
#else
                    char[] chars = ArrayPool<char>.Shared.Rent(maxCharCount);
                    byte[] bytes = ArrayPool<byte>.Shared.Rent(utf8Bytes.Length);
                    utf8Bytes.CopyTo(bytes);
                    try
                    {
                        int written = Encoding.UTF8.GetChars(bytes, 0, utf8Bytes.Length, chars, 0);
                        return chars.AsSpan(0, written).SequenceEqual(this.stringBacking.AsSpan());
                    }
                    finally
                    {
                        ArrayPool<char>.Shared.Return(chars);
                        ArrayPool<byte>.Shared.Return(bytes);
                    }
#endif
                }

                return false;
            }

            /// <summary>
            /// Compare to a sequence of characters.
            /// </summary>
            /// <param name = "chars">The character sequence to compare.</param>
            /// <returns><c>True</c> if teh sequences match.</returns>
            public bool EqualsString(string chars)
            {
                if ((this.backing & Backing.JsonElement) != 0)
                {
                    if (this.jsonElementBacking.ValueKind == JsonValueKind.String)
                    {
                        return this.jsonElementBacking.ValueEquals(chars);
                    }

                    return false;
                }

                if ((this.backing & Backing.String) != 0)
                {
                    return chars.Equals(this.stringBacking, StringComparison.Ordinal);
                }

                return false;
            }

            /// <summary>
            /// Compare to a sequence of characters.
            /// </summary>
            /// <param name = "chars">The character sequence to compare.</param>
            /// <returns><c>True</c> if teh sequences match.</returns>
            public bool EqualsString(ReadOnlySpan<char> chars)
            {
                if ((this.backing & Backing.JsonElement) != 0)
                {
                    if (this.jsonElementBacking.ValueKind == JsonValueKind.String)
                    {
                        return this.jsonElementBacking.ValueEquals(chars);
                    }

                    return false;
                }

                if ((this.backing & Backing.String) != 0)
                {
#if NET8_0_OR_GREATER
            return chars.SequenceEqual(this.stringBacking);
#else
                    return chars.SequenceEqual(this.stringBacking.AsSpan());
#endif
                }

                return false;
            }
#if NET8_0_OR_GREATER
    /// <inheritdoc/>
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if ((this.backing & Backing.String) != 0)
        {
            int length = Math.Min(destination.Length, this.stringBacking.Length);
            this.stringBacking.AsSpan(0, length).CopyTo(destination);
            charsWritten = length;
            return true;
        }

        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.ValueKind == JsonValueKind.String)
            {
                char[] buffer = ArrayPool<char>.Shared.Rent(destination.Length);
                try
                {
                    bool result = this.jsonElementBacking.TryGetValue(FormatSpan, new Output(buffer, destination.Length), out charsWritten);
                    if (result)
                    {
                        buffer.AsSpan(0, charsWritten).CopyTo(destination);
                    }

                    return result;
                }
                finally
                {
                    ArrayPool<char>.Shared.Return(buffer);
                }
            }
            else
            {
                string value = this.jsonElementBacking.GetRawText();
                int length = Math.Min(destination.Length, this.stringBacking.Length);
                this.stringBacking.AsSpan(0, length).CopyTo(destination);
                charsWritten = length;
                return true;
            }
        }

        charsWritten = 0;
        return true;

        static bool FormatSpan(ReadOnlySpan<char> source, in Output output, out int charsWritten)
        {
            int length = Math.Min(output.Length, source.Length);
            source[..length].CopyTo(output.Destination);
            charsWritten = length;
            return true;
        }
    }

    /// <inheritdoc/>
    public string ToString(string? format, IFormatProvider? formatProvider)
    {
        // There is no formatting for the string
        return this.ToString();
    }

    private readonly record struct Output(char[] Destination, int Length);
#endif
        }
    }
}